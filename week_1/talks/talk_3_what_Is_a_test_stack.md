Let's dive into a little more detail still on this critical area of test. The first one we have is this unit or small test. These are almost always created by the individual developer as they're writing their code. And while we're going here, we're going for here what we want to have happen with these tests, is that they're very isolated, meaning that they really are just testing this one specific bit of code that it does what it's supposed to do and they run extremely quick. And the reason for that is we want to be able to have developed a push a button, run a whole mess of these, and then know exactly either, a, everything's okay or, b, it's not, and here is exactly where it's not and exactly why it's not okay. That's how we get the rewards from investing in these small tests. And as we move on, this medium or integration test might actually be referred to by a couple of different terms. Integration test, component test, there are even a few others, and our thing here is if we have function a we're looking at how it interacts with function b, and then, in a separate test, how it interacts with function c. As the software, as we expand the kind of boundary of what the software does, we want to make sure that as we cross those boundaries everything is working properly to frequent source of bugs. And then we have larger system test. And you noticed there's even more terms here. Part of that is that there is more variation on how these tests run and what they do. And so that's why I think this idea of small to medium to large is really helpful because it gives us a nice clear view of which test we're actually talking about. So that if one person uses this term and another person uses this term, we know that basically they're talking about a large test. And so, you may want to refer back to these, that would be familiar with these terms, they refer to these large tests. Now, in this area of system test or large test or test that happen at the end of the pipeline usually, you may have even a couple of other types of tests, performance tests, which test how system performs under a lot of load or a lot of inputs and make sure that it's scalable. And also this is where, generally speaking, a lot of security testing will happen to making sure in an automated fashion that the things that we've done to make sure the system stays secure are in place and they're working. Now, what is exactly the small, medium, large thing mean? Well, I borrowed this from a post that a few folks at Google did on test sizes, and I like it because it is so structured and so consistent. And the key thing really is that as we go from small to medium to large, we're getting test that are going to run slower. And we're also getting test that are going to provide less information, less immediately actionable information at least, less isolation back to the developer. Because if a small test in unit test fails, the developer has a much better idea of exactly where that code is that is failing and probably, by virtue of its isolation, more of an intuition about what might be wrong. And what even makes that intuition better in that, that actionability, what really improves it, is that these tests run extremely fast. So the developer feels like, hey, as I'm going along, I'm changing stuff I can push a button and know if everything is okay in a few seconds perhaps or just a few minutes. So rather than having to get up and get a cup of coffee or move onto something else, I can push a button, know whether I'm okay. That's I think how you'll find that most developers get the most rewards from investing in these unit tests, these small tests. And then as we move outward, we do, in many cases, need to test the boundaries between functions and the system as a whole. You'll notice that in these small tests there's a lot of noes, in fact they are all noes. And really, that's what I mean when I say isolation. So, this small test should have no network access, no database or file system access, or access to any kind of external system, it should be very isolated. If function A does in fact talk to function B,
4:25
then we're going to fake, we're going to take this interaction and we're going to fake it through what you'll often hear referred to as a mock or a stub. So we're going to actually write separate code, and this is part of what the required investment is in unit test. We're going to write code that actually simulates this interaction so that we're really just testing a, and we're controlling for b and just testing a, that's how we get this speed and we get this isolation with these unit tests. So, and you could see down here, they even post the guideline on really how, what is the longest that an individual test should take. In a perfect world you're less in these of course because, again, you're actually doing the job of developing, you don't want to sit around and wait for the output, the result of these, you want to be able to just push them and get feedback immediately.
5:14
When I say test stack, this is what I was talking about, you'll usually have a whole bunch of these unit tests and relatively fewer integration and relatively fewer system tests. You'll often hear about a test pyramid, well, I guess, technically this is kind of a zigorot because there's steps and not a straight line. And so the reason for this being this way is that you're going to have a lot of individual functions that come together and have these key integration points, and then you'll really want to have just a very small amount of these system tests that simulate the key pathways, the critical things that just absolutely cannot be not working when you push stuff to production. And the reason why is that that the speed and the isolation we talked about. And also these tests are, for various reasons, mostly because simulating these interactions has a lot of inherent variation that can come into play, these tests are very expensive to keep working and maintain. And if you have a whole bunch of them, you may get a lot of false positives, lot of things that show up as not working in the test that are in fact either irrelevant or not really broken at all. It's just the test itself that broke, and that is the opposite of what you want. The best test is, you would never want to catch something up at this level that you could've caught down here, and you would never want to have something bubble up to this level that you could've, for instance, caught with an integration test. As you go through your retrospectives on, are we investing in the right places in our test coverage? And if something bad happen in production, there was a retrospective on a bug or a production issue, why did that happen? And we really dig into that and not to blame people but to understand what how could we have, what is the lowest level tests we possibly could have used to make sure that that didn't happen and improve our focus on where we're doing our testing. So, that is an overview of the test stack. What are these different types of tests and why are they important in their particular role and context?


# Traduzido

Vamos mergulhar em um pouco mais de detalhe ainda nesta área crítica de teste. O primeiro que temos é esta unidade ou um pequeno teste. Estes são quase sempre criados pelo desenvolvedor individual como eles estão escrevendo seu código. E enquanto nós estamos indo aqui, nós estamos indo para aqui o que nós queremos ter acontecido com esses testes, é que eles são muito isolados, o que significa que eles realmente estão apenas testando este um bit específico de código que ele faz o que é suposto fazer e eles correm extremamente rápido. E a razão para isso é que queremos ser capazes de ter desenvolvido um apertar um botão, executar uma bagunça inteira destes, e depois saber exatamente qualquer um, a, tudo está bem ou, b, não é, e aqui é exatamente onde não é e exatamente por isso que não está bem. É assim que conseguimos as recompensas de investir nesses pequenos testes. E enquanto nós movemos sobre, este teste médio ou da integração pôde realmente ser referido por alguns termos diferentes. Teste de integração, teste de componente, há até mesmo alguns outros, e nossa coisa aqui é se temos uma função que estamos olhando como ele interage com a função b e, em seguida, em um teste separado, como ele interage com a função c. Como o software, como expandir o tipo de limite do que o software faz, queremos ter certeza de que, como cruzar esses limites tudo está funcionando corretamente para a fonte freqüente de bugs. E então temos um teste de sistema maior. E você notou que há ainda mais termos aqui. Parte disso é que há mais variação em como esses testes são executados e o que eles fazem. E é por isso que eu acho que essa idéia de pequeno a médio e grande é realmente útil porque nos dá uma boa visão clara de que teste estamos realmente falando. De modo que se uma pessoa usa este termo e uma outra pessoa usa este termo, nós sabemos que basicamente estão falando sobre um teste grande. E assim, você pode querer se referir a estes, que estariam familiarizados com estes termos, eles se referem a estes grandes testes. Agora, nesta área de teste do sistema ou grande teste ou teste que acontecem no final do pipeline geralmente, você pode ter até mesmo um par de outros tipos de testes, testes de desempenho, que testar como o sistema executa uma grande quantidade de carga ou um monte de entradas e certifique-se de que é gráfi e. e também este é o lugar onde, em geral, um monte de testes de segurança acontecerá a ter certeza de uma forma automatizada que as coisas que fizemos para se certificar de que o sistema permanece seguro estão no lugar e eles estão trabalhando. Agora, o que é exatamente o pequeno, médio, grande coisa significa? Bem, eu peguei emprestado de um post que algumas pessoas no Google fez em tamanhos de teste, e eu gosto porque ele é tão estruturado e tão consistente. E a principal coisa é realmente que, como vamos de pequeno a médio e grande, estamos recebendo o teste que vai correr mais lento. E também estamos obtendo um teste que vai fornecer menos informações, menos informações imediatamente acionáveis pelo menos, menos isolamento de volta para o desenvolvedor. Porque se um pequeno teste no teste de unidade falhar, o desenvolvedor tem uma idéia muito melhor de exatamente onde esse código é que está falhando e, provavelmente, em virtude de seu isolamento, mais de uma intuição sobre o que pode estar errado. E o que ainda torna essa intuição melhor, que a acionabilidade, o que realmente melhora, é que esses testes correm extremamente rápido. Assim, o desenvolvedor se sente como, Hey, como eu estou indo junto, eu estou mudando coisas que eu posso apertar um botão e saber se tudo está bem em poucos segundos, talvez ou apenas alguns minutos. Então, ao invés de ter que se levantar e tomar uma xícara de café ou passar para outra coisa, eu posso apertar um botão, saber se estou bem. Isso é eu penso como você encontrará que a maioria de colaboradores começ a maioria de recompensas de investir nestes testes de unidade, estes testes pequenos. E então, à medida que nos movemos para fora, nós, em muitos casos, precisamos testar as fronteiras entre as funções e o sistema como um todo. Você vai notar que nestes pequenos testes há um monte de noes, na verdade, eles são todos os noes. E realmente, isso é o que quero dizer quando digo isolamento. Assim, este pequeno teste não deve ter acesso à rede, nenhum banco de dados ou acesso ao sistema de arquivos, ou acesso a qualquer tipo de sistema externo, ele deve ser muito isolado. Se a função A não falar de fato para a função B, 


Então nós vamos fingir, nós vamos tomar essa interação e nós vamos fingir isso através do que você vai ouvir muitas vezes referida como um mock ou um esboço. Então, nós vamos realmente escrever código separado, e isso é parte do que o investimento exigido está em teste de unidade. Vamos escrever código que simule essa interação para que estejamos testando apenas um, e estamos controlando para b e testando um, é assim que conseguimos essa velocidade e conseguimos esse isolamento com esses testes unitários. Assim, e você poderia ver aqui em baixo, eles até mesmo postar a diretriz sobre realmente como, o que é o mais longo que um teste individual deve tomar. Em um mundo perfeito você é menos nestes naturalmente porque, outra vez, você está fazendo realmente o trabalho do desenvolvimento, você não quer sentar-se ao redor e esperar a saída, o resultado destes, você quer poder apenas empurrá-los e começ o gabarito imediatamente. 5:14 Quando eu digo pilha de teste, isso é o que eu estava falando, você geralmente tem um monte desses testes unitários e relativamente menos integração e relativamente menos testes do sistema. Muitas vezes você vai ouvir sobre uma pirâmide de teste, bem, eu acho, tecnicamente este é um tipo de zigorot porque há passos e não uma linha reta. E assim a razão para este ser desta forma é que você vai ter um monte de funções individuais que se reúnem e têm esses pontos de integração chave, e então você realmente vai querer ter apenas uma quantidade muito pequena desses testes do sistema que simulam os caminhos-chave , as coisas críticas que simplesmente não podem estar funcionando quando você empurra coisas para a produção. E a razão pela qual é que a velocidade eo isolamento que falamos. E também esses testes são, por várias razões, principalmente porque simular essas interações tem um monte de variação inerente que pode entrar em jogo, esses testes são muito caros para manter o trabalho e manter. E se você tem um monte deles, você pode ter um monte de falsos positivos, muitas coisas que aparecem como não trabalhar no teste que são de fato ou irrelevante ou não realmente quebrado em tudo. É apenas o teste em si que quebrou, e isso é o oposto do que você quer. O melhor teste é, você nunca iria querer pegar algo a este nível que você poderia ter pego aqui, e você nunca iria querer ter algo bolha até este nível que você poderia ter, por exemplo, capturado com um teste de integração. Como você passar por suas retrospectivas sobre, estamos investindo nos lugares certos em nossa cobertura de teste? E se algo ruim acontecer na produção, houve uma retrospectiva sobre um bug ou uma questão de produção, por que isso aconteceu? E nós realmente cavar em que e não culpar as pessoas, mas para entender o que como poderíamos ter, o que é o nível mais baixo testes que possivelmente poderia ter usado para se certificar de que isso não aconteceu e melhorar o nosso foco em onde estamos fazendo o nosso teste. Então, isso é uma visão geral da pilha de teste. Quais são esses diferentes tipos de testes e por que eles são importantes em seu papel e contexto particular?
